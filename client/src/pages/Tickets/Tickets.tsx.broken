import { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  Card,
  CardContent,
  Grid,
  Chip,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Fab,
  Tooltip,
  Badge,
  Avatar,
  List,
  ListItem,
  ListItemText,
  ListItemAvatar,
  Divider,
  Alert,
  CircularProgress,
  Tabs,
  Tab,
  Paper
} from '@mui/material';
import {
  Add,
  Search,
  FilterList,
  PlayArrow,
  Stop,
  WatchLater,
  PriorityHigh,
  Assignment,
  Business,
  Schedule,
  TrendingUp,
  Warning,
  OpenInNew
} from '@mui/icons-material';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import { toast } from 'react-hot-toast';
import { useNavigate } from 'react-router-dom';
import { ticketsAPI, usersAPI, companiesAPI } from '../../services/api';
import { useAuth } from '../../contexts/AuthContext';

interface Ticket {
  _id: string;
  ticketNumber: string;
  title: string;
  description: string;
  status: 'open' | 'in_progress' | 'resolved' | 'closed';
  priority: 'low' | 'medium' | 'high' | 'critical';
  category: 'technical' | 'billing' | 'feature_request' | 'bug_report' | 'general';
  reporter: {
    _id: string;
    firstName: string;
    lastName: string;
    email: string;
  };
  assignee?: {
    _id: string;
    firstName: string;
    lastName: string;
    email: string;
  };
  company: {
    _id: string;
    name: string;
  };
  estimatedTime: number;
  actualTime: number;
  timeEntries: Array<{
    _id: string;
    description: string;
    startTime: string;
    endTime?: string;
    duration: number;
    user: {
      _id: string;
      firstName: string;
      lastName: string;
    };
    isActive: boolean;
  }>;
  sla: {
    type: 'response' | 'resolution';
    targetTime: number;
    startTime: string;
    endTime?: string;
    isBreached: boolean;
  };
  escalationLevel: number;
  escalatedTo?: {
    _id: string;
    firstName: string;
    lastName: string;
  };
  watchers: Array<{
    _id: string;
    firstName: string;
    lastName: string;
  }>;
  tags: string[];
  dueDate?: string;
  createdAt: string;
  updatedAt: string;
}

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`ticket-tabpanel-${index}`}
      aria-labelledby={`ticket-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ p: 3 }}>{children}</Box>}
    </div>
  );
}

const Tickets: React.FC = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const [tabValue, setTabValue] = useState(0);
  const [filters, setFilters] = useState({
    status: '',
    priority: '',
    category: '',
    assignee: '',
    search: ''
  });
  const [showFilters, setShowFilters] = useState(false);
  const [selectedTicket, setSelectedTicket] = useState<Ticket | null>(null);
  const [showTicketDialog, setShowTicketDialog] = useState(false);
  const [ticketForm, setTicketForm] = useState({
    title: '',
    description: '',
    priority: 'medium',
    category: 'general',
    assignee: '',
    company: ''
  });
  const [formErrors, setFormErrors] = useState<{[key: string]: string}>({});
  const [nowTs, setNowTs] = useState<number>(Date.now());
  const [activeTab, setActiveTab] = useState(0);
  const [filterStatus, setFilterStatus] = useState<string>('');
  const [filterPriority, setFilterPriority] = useState<string>('');
  const [filterCategory, setFilterCategory] = useState<string>('');
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [showReopenRequests, setShowReopenRequests] = useState(false);
  const [showStartTrackingDialog, setShowStartTrackingDialog] = useState(false);
  const [selectedTicketForTracking, setSelectedTicketForTracking] = useState<Ticket | null>(null);

  // Tick every second to update live timers
  useEffect(() => {
    const intervalId = setInterval(() => {
      setNowTs(Date.now());
    }, 1000);
    return () => clearInterval(intervalId);
  }, []);

  // Fetch tickets
  const { data: ticketsData, isLoading, error } = useQuery(
    ['tickets', filters],
    () => ticketsAPI.getAll(filters),
    {
      refetchOnWindowFocus: false,
    }
  );

  // Fetch users for assignee filter
  const { data: usersData } = useQuery(
    'users-for-tickets',
    () => usersAPI.getForTickets(),
    {
      refetchOnWindowFocus: false,
    }
  );

  // Fetch companies for ticket creation
  const { data: companiesData } = useQuery(
    'companies-for-tickets',
    () => companiesAPI.getForTickets(),
    {
      refetchOnWindowFocus: false,
    }
  );

  // Fetch all reopen requests for admin
  const { data: allReopenRequestsData, isLoading: isLoadingReopenRequests } = useQuery(
    'all-reopen-requests',
    () => ticketsAPI.getAllReopenRequests(),
    { 
      enabled: user?.role === 'admin',
      refetchOnWindowFocus: false 
    }
  );

  const allReopenRequests = Array.isArray(allReopenRequestsData?.data) 
    ? allReopenRequestsData!.data 
    : [];

  // Mutations for reopen approval/rejection
  const approveReopenMutation = useMutation(
    ({ requestId, reviewNote }: { requestId: string; reviewNote?: string }) =>
      ticketsAPI.approveReopenRequest(requestId, reviewNote),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('all-reopen-requests');
        queryClient.invalidateQueries('tickets');
        toast.success('Reopen request approved');
      },
      onError: (error: any) => {
        toast.error(error.response?.data?.message || 'Failed to approve reopen request');
      }
    }
  );

  const rejectReopenMutation = useMutation(
    ({ requestId, reviewNote }: { requestId: string; reviewNote?: string }) =>
      ticketsAPI.rejectReopenRequest(requestId, reviewNote),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('all-reopen-requests');
        toast.success('Reopen request rejected');
      },
      onError: (error: any) => {
        toast.error(error.response?.data?.message || 'Failed to reject reopen request');
      }
    }
  );

  const handleApproveReopen = (requestId: string, reviewNote?: string) => {
    approveReopenMutation.mutate({ requestId, reviewNote });
  };

  const handleRejectReopen = (requestId: string, reviewNote?: string) => {
    rejectReopenMutation.mutate({ requestId, reviewNote });
  };

  // Time tracking mutations
  const startTrackingMutation = useMutation(
    ({ ticketId, description }: { ticketId: string; description: string }) =>
      ticketsAPI.startTracking(ticketId, description),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['tickets']);
        toast.success('Time tracking started');
      },
      onError: (error: any) => {
        toast.error(error.response?.data?.message || 'Failed to start tracking');
      },
    }
  );

  const stopTrackingMutation = useMutation(
    (ticketId: string) => ticketsAPI.stopTracking(ticketId),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['tickets']);
        toast.success('Time tracking stopped');
      },
      onError: (error: any) => {
        toast.error(error.response?.data?.message || 'Failed to stop tracking');
      },
    }
  );

  // Watch/unwatch mutations
  const watchMutation = useMutation(
    (ticketId: string) => ticketsAPI.watch(ticketId),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['tickets']);
        toast.success('Added as watcher');
      },
      onError: (error: any) => {
        toast.error(error.response?.data?.message || 'Failed to add watcher');
      },
    }
  );

  const unwatchMutation = useMutation(
    (ticketId: string) => ticketsAPI.unwatch(ticketId),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['tickets']);
        toast.success('Removed as watcher');
      },
      onError: (error: any) => {
        toast.error(error.response?.data?.message || 'Failed to remove watcher');
      },
    }
  );

  // Create ticket mutation
  const createTicketMutation = useMutation(
    (ticketData: any) => ticketsAPI.create(ticketData),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['tickets']);
        toast.success('Ticket created successfully');
        setShowTicketDialog(false);
        setTicketForm({
          title: '',
          description: '',
          priority: 'medium',
          category: 'general',
          assignee: '',
          company: ''
        });
        setFormErrors({});
      },
      onError: (error: any) => {
        toast.error(error.response?.data?.message || 'Failed to create ticket');
      },
    }
  );

  const tickets = ticketsData?.data?.tickets || [];
  const users = usersData?.data?.users || [];
  const companies = companiesData?.data?.companies || [];



  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };

  const handleFilterChange = (field: string, value: string) => {
    setFilters(prev => ({ ...prev, [field]: value }));
  };

  const clearFilters = () => {
    setFilters({
      status: '',
      priority: '',
      category: '',
      assignee: '',
      search: ''
    });
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'open':
        return 'default';
      case 'in_progress':
        return 'primary';
      case 'resolved':
        return 'success';
      case 'closed':
        return 'secondary';
      default:
        return 'default';
    }
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'low':
        return 'success';
      case 'medium':
        return 'warning';
      case 'high':
        return 'error';
      case 'critical':
        return 'error';
      default:
        return 'default';
    }
  };

  const getPriorityIcon = (priority: string) => {
    switch (priority) {
      case 'critical':
        return <PriorityHigh color="error" />;
      case 'high':
        return <PriorityHigh color="warning" />;
      default:
        return null;
    }
  };

  const formatHms = (totalSeconds: number) => {
    const clamped = Math.max(0, Math.floor(totalSeconds));
    const hours = Math.floor(clamped / 3600);
    const minutes = Math.floor((clamped % 3600) / 60);
    const seconds = clamped % 60;
    const hh = String(hours).padStart(2, '0');
    const mm = String(minutes).padStart(2, '0');
    const ss = String(seconds).padStart(2, '0');
    return `${hh}:${mm}:${ss}`;
  };

  const getActiveElapsedSeconds = (ticket: Ticket) => {
    const active = ticket.timeEntries.find(entry => entry.isActive);
    if (!active) return 0;
    const startMs = new Date(active.startTime).getTime();
    return Math.max(0, Math.floor((nowTs - startMs) / 1000));
  };

  const getTotalSecondsInternal = (ticket: Ticket) => {
    const baseSeconds = Math.max(0, Math.floor((ticket.actualTime || 0) * 60));
    const activeSeconds = hasActiveTimeEntry(ticket) ? getActiveElapsedSeconds(ticket) : 0;
    return baseSeconds + activeSeconds;
  };

  const getCustomerRoundedHours = (ticket: Ticket) => {
    const totalSeconds = getTotalSecondsInternal(ticket);
    if (totalSeconds <= 0) return 0;
    const hours = Math.ceil(totalSeconds / 3600);
    return Math.max(1, hours);
  };
  

  const isWatching = (ticket: Ticket) => {
    return ticket.watchers.some(watcher => watcher._id === (user as any)?._id);
  };

  const hasActiveTimeEntry = (ticket: Ticket) => {
    return ticket.timeEntries.some(entry => entry.isActive);
  };

  const handleStartTracking = (ticket: Ticket) => {
    setSelectedTicketForTracking(ticket);
    setShowStartTrackingDialog(true);
  };

  const handleConfirmStartTracking = () => {
    if (!selectedTicketForTracking) return;
    const description = `Work on ${selectedTicketForTracking.ticketNumber}`;
    startTrackingMutation.mutate({ ticketId: selectedTicketForTracking._id, description });
    setShowStartTrackingDialog(false);
    setSelectedTicketForTracking(null);
  };

  const handleCancelStartTracking = () => {
    setShowStartTrackingDialog(false);
    setSelectedTicketForTracking(null);
  };

  const handleStopTracking = (ticket: Ticket) => {
    stopTrackingMutation.mutate(ticket._id);
  };

  const handleWatchToggle = (ticket: Ticket) => {
    if (isWatching(ticket)) {
      unwatchMutation.mutate(ticket._id);
    } else {
      watchMutation.mutate(ticket._id);
    }
  };

  const handleFormChange = (field: string, value: any) => {
    setTicketForm(prev => ({ ...prev, [field]: value }));
    if (formErrors[field]) {
      setFormErrors(prev => ({ ...prev, [field]: '' }));
    }
  };

  const validateForm = () => {
    const newErrors: {[key: string]: string} = {};

    if (!ticketForm.title.trim()) {
      newErrors.title = 'Title is required';
    }

    if (!ticketForm.description.trim()) {
      newErrors.description = 'Description is required';
    }

    if (!ticketForm.company || ticketForm.company === '') {
      newErrors.company = 'Company is required';
    }



    // Role-based validation
    if (ticketForm.priority === 'high' && !canSetHighPriority()) {
      newErrors.priority = 'You cannot set high priority tickets';
    }

    if (ticketForm.priority === 'critical' && !canSetCriticalPriority()) {
      newErrors.priority = 'Only admins can set critical priority';
    }

    setFormErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleCreateTicket = () => {
    if (!validateForm()) {
      return;
    }

    const submitData: any = {
      ...ticketForm
    };
    
    // Remove assignee property if it's empty
    if (!submitData.assignee) {
      delete submitData.assignee;
    }

    console.log('Submitting ticket data:', submitData);
    createTicketMutation.mutate(submitData);
  };

  const handleCloseDialog = () => {
    setShowTicketDialog(false);
    setTicketForm({
      title: '',
      description: '',
      priority: 'medium',
      category: 'general',
      assignee: '',
      company: ''
    });
    setFormErrors({});
  };

  // Set default company for regular users when dialog opens
  const handleOpenDialog = () => {
    const defaultCompany = shouldAutoFillCompany() ? getUserCompany() : '';
    setTicketForm(prev => ({
      ...prev,
      company: defaultCompany
    }));
    setShowTicketDialog(true);
  };

  // Role-based helper functions
  const canCreateTicket = () => {
    return ['admin', 'manager', 'agent', 'user'].includes(user?.role || '');
  };

  const canAssignTickets = () => {
    return ['admin', 'manager'].includes(user?.role || '');
  };

  const canSelectCompany = () => {
    return ['admin'].includes(user?.role || '');
  };

  const getUserCompany = () => {
    return user?.company || '';
  };

  const shouldAutoFillCompany = () => {
    return !['admin'].includes(user?.role || '');
  };

  const canSetHighPriority = () => {
    return ['admin', 'manager'].includes(user?.role || '');
  };

  const canSetCriticalPriority = () => {
    return ['admin'].includes(user?.role || '');
  };

  const filteredTickets = tickets.filter((ticket: Ticket) => {
    if (tabValue === 1) return ticket.status === 'open';
    if (tabValue === 2) return ticket.status === 'in_progress';
    if (tabValue === 3) return ticket.status === 'resolved';
    if (tabValue === 4) return ticket.status === 'closed';
    if (tabValue === 5) return false; // Reopen requests tab - don't show tickets
    return true; // tabValue === 0 => All
  });

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box sx={{ p: 3 }}>
        <Alert severity="error">
          Failed to load tickets. Please try again.
        </Alert>
      </Box>
    );
  }

  return (
    <Box>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
        <Typography variant="h4" component="h1" sx={{ fontWeight: 'bold' }}>
          Tickets
        </Typography>
        {canCreateTicket() && (
          <Button
            variant="contained"
            startIcon={<Add />}
            onClick={handleOpenDialog}
            sx={{ px: 3 }}
          >
            Create Ticket
          </Button>
        )}
      </Box>

      {/* Filters */}
      <Card sx={{ mb: 3 }}>
        <CardContent>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
            <TextField
              placeholder="Search tickets..."
              value={filters.search}
              onChange={(e) => handleFilterChange('search', e.target.value)}
              InputProps={{
                startAdornment: <Search sx={{ mr: 1, color: 'text.secondary' }} />
              }}
              size="small"
              sx={{ minWidth: 200 }}
            />
            <Button
              startIcon={<FilterList />}
              onClick={() => setShowFilters(!showFilters)}
              variant={showFilters ? 'contained' : 'outlined'}
              size="small"
            >
              Filters
            </Button>
            {Object.values(filters).some(f => f !== '') && (
              <Button onClick={clearFilters} size="small">
                Clear
              </Button>
            )}
          </Box>

          {showFilters && (
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6} md={2}>
                <FormControl fullWidth size="small">
                  <InputLabel>Status</InputLabel>
                  <Select
                    value={filters.status}
                    onChange={(e) => handleFilterChange('status', e.target.value)}
                    label="Status"
                  >
                    <MenuItem value="">All</MenuItem>
                    <MenuItem value="open">Open</MenuItem>
                    <MenuItem value="in_progress">In Progress</MenuItem>
                    <MenuItem value="resolved">Resolved</MenuItem>
                    <MenuItem value="closed">Closed</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              <Grid item xs={12} sm={6} md={2}>
                <FormControl fullWidth size="small">
                  <InputLabel>Priority</InputLabel>
                  <Select
                    value={filters.priority}
                    onChange={(e) => handleFilterChange('priority', e.target.value)}
                    label="Priority"
                  >
                    <MenuItem value="">All</MenuItem>
                    <MenuItem value="low">Low</MenuItem>
                    <MenuItem value="medium">Medium</MenuItem>
                    <MenuItem value="high">High</MenuItem>
                    <MenuItem value="critical">Critical</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              <Grid item xs={12} sm={6} md={2}>
                <FormControl fullWidth size="small">
                  <InputLabel>Category</InputLabel>
                  <Select
                    value={filters.category}
                    onChange={(e) => handleFilterChange('category', e.target.value)}
                    label="Category"
                  >
                    <MenuItem value="">All</MenuItem>
                    <MenuItem value="technical">Technical</MenuItem>
                    <MenuItem value="billing">Billing</MenuItem>
                    <MenuItem value="feature_request">Feature Request</MenuItem>
                    <MenuItem value="bug_report">Bug Report</MenuItem>
                    <MenuItem value="general">General</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <FormControl fullWidth size="small">
                  <InputLabel>Assignee</InputLabel>
                  <Select
                    value={filters.assignee}
                    onChange={(e) => handleFilterChange('assignee', e.target.value)}
                    label="Assignee"
                  >
                    <MenuItem value="">All</MenuItem>
                                         {users
                       .filter((u: any) => ['agent', 'manager', 'admin'].includes(u.role))
                       .map((user: any) => (
                         <MenuItem key={user._id} value={user._id}>
                           {user.firstName} {user.lastName}
                         </MenuItem>
                       ))}
                  </Select>
                </FormControl>
              </Grid>
            </Grid>
          )}
        </CardContent>
      </Card>

      {/* Tabs */}
      <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
        <Tabs value={tabValue} onChange={handleTabChange}>
          <Tab label={`All (${tickets.length})`} />
          <Tab label={`Open (${tickets.filter((t: Ticket) => t.status === 'open').length})`} />
          <Tab label={`In Progress (${tickets.filter((t: Ticket) => t.status === 'in_progress').length})`} />
          <Tab label={`Resolved (${tickets.filter((t: Ticket) => t.status === 'resolved').length})`} />
          <Tab label={`Closed (${tickets.filter((t: Ticket) => t.status === 'closed').length})`} />
          {user?.role === 'admin' && (
            <Tab label={`Reopen Requests ${Array.isArray(allReopenRequests) && allReopenRequests.filter((r: any) => r.status === 'pending').length > 0 ? `(${allReopenRequests.filter((r: any) => r.status === 'pending').length})` : ''}`} />
          )}
        </Tabs>
      </Box>

      {/* Content based on tab */}
      {tabValue === 5 ? (
        // Reopen Requests Tab
        <Box>
          {isLoadingReopenRequests ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
              <CircularProgress />
            </Box>
          ) : Array.isArray(allReopenRequests) && allReopenRequests.length === 0 ? (
            <Box sx={{ textAlign: 'center', py: 8 }}>
              <Typography variant="h6" color="text.secondary">
                No reopen requests found
              </Typography>
              <Typography variant="body2" color="text.secondary">
                All tickets are up to date
              </Typography>
            </Box>
                     ) : (
             <List>
               {allReopenRequests.map((request: any) => (
                 <ListItem
                   key={request._id}
                   sx={{
                     border: 1,
                     borderColor: 'divider',
                     borderRadius: 1,
                     mb: 1,
                     bgcolor: 'background.paper'
                   }}
                 >
                   <ListItemText
                     primary={
                       <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                         <Box>
                           <Typography variant="h6" component="span">
                             {request.ticket.title}
                           </Typography>
                           <Typography variant="body2" color="text.secondary">
                             Ticket #{request.ticket.ticketNumber}
                           </Typography>
                         </Box>
                         <Chip
                           label={request.status.toUpperCase()}
                           color={request.status === 'pending' ? 'warning' : 'default'}
                           size="small"
                         />
                       </Box>
                     }
                     secondary={
                       <Box>
                         <Typography variant="body2" sx={{ mb: 1 }}>
                           <strong>Reason:</strong> {request.reason}
                         </Typography>
                         
                         <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                           <Typography variant="caption" color="text.secondary">
                             Requested by {request.requestedBy.firstName} {request.requestedBy.lastName} on{' '}
                             {new Date(request.createdAt).toLocaleDateString()}
                           </Typography>
                           
                           {request.status === 'pending' && (
                             <Box sx={{ display: 'flex', gap: 1 }}>
                               <Button
                                 variant="contained"
                                 color="success"
                                 size="small"
                                 onClick={() => handleApproveReopen(request._id)}
                                 disabled={approveReopenMutation.isLoading}
                               >
                                 Approve
                               </Button>
                               <Button
                                 variant="outlined"
                                 color="error"
                                 size="small"
                                 onClick={() => handleRejectReopen(request._id)}
                                 disabled={rejectReopenMutation.isLoading}
                               >
                                 Reject
                               </Button>
                             </Box>
                           )}
                         </Box>
                       </Box>
                     }
                   />
                 </ListItem>
               ))}
             </List>
          )}
        </Box>
      ) : (
        // Regular Tickets
        <>
          {filteredTickets.length === 0 ? (
            <Box sx={{ textAlign: 'center', py: 8 }}>
              <Typography variant="h6" color="text.secondary">
                No tickets found
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Create your first ticket to get started
              </Typography>
            </Box>
          ) : (
            // Regular Tickets List
            <List>
              {filteredTickets.map((ticket: Ticket) => (
                <ListItem
                  key={ticket._id}
                  sx={{
                    cursor: 'pointer',
                    '&:hover': { bgcolor: 'action.hover' },
                    border: 1,
                    borderColor: 'divider',
                    borderRadius: 1,
                    mb: 1,
                    bgcolor: 'background.paper'
                  }}
                  onClick={() => navigate(`/tickets/${ticket._id}`)}
                >
                  <ListItemAvatar>
                    <Avatar>
                      {ticket.reporter.firstName[0]}
                    </Avatar>
                  </ListItemAvatar>
                  <ListItemText
                    primary={
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <Typography variant="h6" component="span">
                          {ticket.title}
                        </Typography>
                        <Box sx={{ display: 'flex', gap: 1 }}>
                          <Chip
                            label={ticket.status.toUpperCase()}
                            color={
                              ticket.status === 'open' ? 'error' :
                              ticket.status === 'in_progress' ? 'warning' :
                              ticket.status === 'resolved' ? 'info' : 'success'
                            }
                            size="small"
                          />
                          <Chip
                            label={ticket.priority.toUpperCase()}
                            color={
                              ticket.priority === 'critical' ? 'error' :
                              ticket.priority === 'high' ? 'warning' :
                              ticket.priority === 'medium' ? 'info' : 'default'
                            }
                            size="small"
                          />
                        </Box>
                      </Box>
                    }
                    secondary={
                      <Box>
                        <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                          {ticket.description}
                        </Typography>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                          <Box sx={{ display: 'flex', gap: 2, alignItems: 'center' }}>
                            <Typography variant="caption" color="text.secondary">
                              #{ticket.ticketNumber}
                            </Typography>
                            <Typography variant="caption" color="text.secondary">
                              {ticket.reporter.firstName} {ticket.reporter.lastName}
                            </Typography>
                            <Typography variant="caption" color="text.secondary">
                              {new Date(ticket.createdAt).toLocaleDateString()}
                            </Typography>
                            {ticket.timeEntries && ticket.timeEntries.length > 0 && (
                              <Typography variant="caption" color="text.secondary">
                                Admin: {formatHms(getTotalSecondsInternal(ticket))} • Customer: {getCustomerRoundedHours(ticket)}h
                              </Typography>
                            )}
                          </Box>
                          <Box sx={{ display: 'flex', gap: 1 }}>
                            <Tooltip title={hasActiveTimeEntry(ticket) ? 'Stop tracking' : 'Start tracking'}>
                              <IconButton
                                size="small"
                                color={hasActiveTimeEntry(ticket) ? 'error' : 'primary'}
                                disabled={ticket.status === 'closed'}
                                onClick={(e) => {
                                  e.stopPropagation();
                                  hasActiveTimeEntry(ticket) 
                                    ? handleStopTracking(ticket) 
                                    : handleStartTracking(ticket);
                                }}
                              >
                                {hasActiveTimeEntry(ticket) ? <Stop /> : <PlayArrow />}
                              </IconButton>
                            </Tooltip>
                            <Tooltip title={isWatching(ticket) ? 'Remove from watchlist' : 'Add to watchlist'}>
                              <IconButton
                                size="small"
                                color={isWatching(ticket) ? 'primary' : 'default'}
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleWatchToggle(ticket);
                                }}
                              >
                                <WatchLater />
                              </IconButton>
                            </Tooltip>
                          </Box>
                        </Box>
                      </Box>
                    }
                  />
                </ListItem>
              ))}
            </List>
      )}
        </>
      )}

      {/* Create Ticket Dialog */}
      <Dialog
        open={showTicketDialog}
        onClose={handleCloseDialog}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Create New Ticket</DialogTitle>
        <DialogContent>
          <Box sx={{ pt: 1 }}>
            <Grid container spacing={2}>
              {/* Title */}
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  label="Title"
                  value={ticketForm.title}
                  onChange={(e) => handleFormChange('title', e.target.value)}
                  error={!!formErrors.title}
                  helperText={formErrors.title}
                  required
                />
              </Grid>

              {/* Description */}
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  multiline
                  rows={3}
                  label="Description"
                  value={ticketForm.description}
                  onChange={(e) => handleFormChange('description', e.target.value)}
                  error={!!formErrors.description}
                  helperText={formErrors.description}
                  required
                />
              </Grid>

              {/* Priority and Category */}
              <Grid item xs={12} sm={6}>
                <FormControl fullWidth error={!!formErrors.priority}>
                  <InputLabel>Priority</InputLabel>
                  <Select
                    value={ticketForm.priority}
                    onChange={(e) => handleFormChange('priority', e.target.value)}
                    label="Priority"
                  >
                    <MenuItem value="low">Low</MenuItem>
                    <MenuItem value="medium">Medium</MenuItem>
                    {canSetHighPriority() && (
                      <MenuItem value="high">High</MenuItem>
                    )}
                    {canSetCriticalPriority() && (
                      <MenuItem value="critical">Critical</MenuItem>
                    )}
                  </Select>
                  {formErrors.priority && (
                    <Typography variant="caption" color="error" sx={{ mt: 0.5 }}>
                      {formErrors.priority}
                    </Typography>
                  )}
                </FormControl>
              </Grid>

              <Grid item xs={12} sm={6}>
                <FormControl fullWidth>
                  <InputLabel>Category</InputLabel>
                  <Select
                    value={ticketForm.category}
                    onChange={(e) => handleFormChange('category', e.target.value)}
                    label="Category"
                  >
                    <MenuItem value="technical">Technical</MenuItem>
                    <MenuItem value="billing">Billing</MenuItem>
                    <MenuItem value="feature_request">Feature Request</MenuItem>
                    <MenuItem value="bug_report">Bug Report</MenuItem>
                    <MenuItem value="general">General</MenuItem>
                  </Select>
                </FormControl>
              </Grid>

              {/* Company and Assignee */}
              <Grid item xs={12} sm={6}>
                <FormControl fullWidth error={!!formErrors.company}>
                  <InputLabel>Company</InputLabel>
                  <Select
                    value={ticketForm.company}
                    onChange={(e) => handleFormChange('company', e.target.value)}
                    label="Company"
                    required
                  >
                    {canSelectCompany() ? (
                      // Admin can see all companies
                      companies.map((company: any) => (
                        <MenuItem key={company._id} value={company._id}>
                          {company.name}
                        </MenuItem>
                      ))
                    ) : (
                      // Other users can only see their own company
                      companies.map((company: any) => (
                        <MenuItem key={company._id} value={company._id}>
                          {company.name}
                        </MenuItem>
                      ))
                    )}
                  </Select>
                  {formErrors.company && (
                    <Typography variant="caption" color="error" sx={{ mt: 0.5 }}>
                      {formErrors.company}
                    </Typography>
                  )}
                </FormControl>
              </Grid>

              {canAssignTickets() && (
                <Grid item xs={12} sm={6}>
                  <FormControl fullWidth>
                    <InputLabel>Assignee</InputLabel>
                    <Select
                      value={ticketForm.assignee}
                      onChange={(e) => handleFormChange('assignee', e.target.value)}
                      label="Assignee"
                    >
                      <MenuItem value="">Unassigned</MenuItem>
                      {users
                        .filter((u: any) => ['agent', 'manager', 'admin'].includes(u.role))
                        .map((user: any) => (
                          <MenuItem key={user._id} value={user._id}>
                            {user.firstName} {user.lastName}
                          </MenuItem>
                        ))}
                    </Select>
                  </FormControl>
                </Grid>
              )}


            </Grid>
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Cancel</Button>
          <Button 
            variant="contained" 
            onClick={handleCreateTicket}
            disabled={createTicketMutation.isLoading}
          >
            {createTicketMutation.isLoading ? (
              <>
                <CircularProgress size={20} sx={{ mr: 1 }} />
                Creating...
              </>
            ) : (
              'Create Ticket'
            )}
          </Button>
        </DialogActions>
      </Dialog>

      {/* Start Tracking Confirmation Dialog */}
      <Dialog 
        open={showStartTrackingDialog} 
        onClose={handleCancelStartTracking}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
          <PlayArrow color="primary" />
          Start Time Tracking
        </DialogTitle>
        <DialogContent>
          <Typography variant="body1" sx={{ mb: 2 }}>
            Are you sure you want to start time tracking for:
          </Typography>
          {selectedTicketForTracking && (
            <Box sx={{ 
              p: 2, 
              bgcolor: 'grey.50', 
              borderRadius: 1, 
              border: 1, 
              borderColor: 'grey.200' 
            }}>
              <Typography variant="h6" sx={{ mb: 1 }}>
                {selectedTicketForTracking.title}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Ticket #{selectedTicketForTracking.ticketNumber}
              </Typography>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCancelStartTracking}>
            Cancel
          </Button>
          <Button 
            variant="contained" 
            color="primary"
            onClick={handleConfirmStartTracking}
            disabled={startTrackingMutation.isLoading}
            startIcon={<PlayArrow />}
          >
            {startTrackingMutation.isLoading ? (
              <>
                <CircularProgress size={20} sx={{ mr: 1 }} />
                Starting...
              </>
            ) : (
              'Start Tracking'
            )}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default Tickets;
